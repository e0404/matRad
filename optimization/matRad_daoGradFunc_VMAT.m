function g = matRad_daoGradFunc_VMAT(apertureInfoVec,dij,cst,options,daoVec2ApertureInfo)
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% matRad IPOPT callback: gradient function for direct aperture optimization
%
% call
%   g = matRad_daoGradFunc(apertureInfoVec,apertureInfo,dij,cst,type)
%
% input
%   apertureInfoVect: aperture info in form of vector
%   apertureInfo:     aperture info struct
%   dij:              matRad dij struct as generated by bixel-based dose calculation
%   cst:              matRad cst struct
%   options: option struct defining the type of optimization
%
% output
%   g: gradient
%
% References
%   [1] http://dx.doi.org/10.1118/1.4914863
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Copyright 2015 the matRad development team.
%
% This file is part of the matRad project. It is subject to the license
% terms in the LICENSE file found in the top-level directory of this
% distribution and at https://github.com/e0404/matRad/LICENSES.txt. No part
% of the matRad project, including this file, may be copied, modified,
% propagated, or distributed except according to the terms contained in the
% LICENSE file.
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% read in the global apertureInfo and apertureVector variables
global matRad_global_apertureInfo;
% update apertureInfo from the global variable
apertureInfo = matRad_global_apertureInfo;

% update apertureInfo, bixel weight vector an mapping of leafes to bixels
if ~isequal(apertureInfoVec,apertureInfo.apertureVector)
    apertureInfo = daoVec2ApertureInfo(apertureInfo,apertureInfoVec);
    matRad_global_apertureInfo = apertureInfo;
end



% bixel based gradient calculation
bixelG = matRad_gradFuncWrapper(apertureInfo.bixelWeights,dij,cst,options);

% allocate gradient vector for aperture weights and leaf positions
%changed from NaNs to zeros
g = zeros(size(apertureInfoVec,1),1);

offset = 1;

% 1. calculate aperatureGrad
% 2. find corresponding bixel to the leaf Positions and aperture
% weights to calculate the gradient

% loop over all beams

optBeams = find([apertureInfo.beam(:).optimizeBeam]);

for i = 1:numel(apertureInfo.beam)
    
    % get used bixels in beam
    ix = ~isnan(apertureInfo.beam(i).bixelIndMap);
    
    if apertureInfo.beam(i).optimizeBeam
        %optimized beam, do regular gradient
        %must always add to existing gradient, since gradient comes
        %from optimized and interpolated beams
        g(offset) = g(offset)+apertureInfo.beam(i).shape(1).shapeMap(ix)' ...
            * bixelG(apertureInfo.beam(i).bixelIndMap(ix)) ./ apertureInfo.beam(i).shape(1).jacobiScale;
        
        
        %gradient wrt leaf positions
        indInOptVec = apertureInfo.beam(i).shape(1).vectorOffset-1+[(1:apertureInfo.beam(i).numOfActiveLeafPairs) apertureInfo.totalNumOfLeafPairs+(1:apertureInfo.beam(i).numOfActiveLeafPairs)];
        indInBixVec = apertureInfo.beam(i).bixOffset-1+[(1:apertureInfo.beam(i).numOfActiveLeafPairs) apertureInfo.doseTotalNumOfLeafPairs+(1:apertureInfo.beam(i).numOfActiveLeafPairs)];
        
        g(indInOptVec) = g(indInOptVec)+apertureInfo.beam(i).shape(1).weight*bixelG(apertureInfo.bixelIndices(indInBixVec)) / apertureInfo.bixelWidth;
        
        %increment offset
        offset = offset+1;
    else
        %not optimized beam, aperture weight is interpolated between
        %previous and next optimized weights
        
        %give fraction of gradient to previous optimized beam
        
        %first weight
        lastOptInd = find(optBeams == apertureInfo.beam(i).lastOptIndex,1);
        g(lastOptInd) = g(lastOptInd)+apertureInfo.beam(i).fracFromLastOpt.*(apertureInfo.beam(i).time./apertureInfo.beam(apertureInfo.beam(i).lastOptIndex).time) ...
            *apertureInfo.beam(i).shape(1).shapeMap(ix)' * bixelG(apertureInfo.beam(i).bixelIndMap(ix))./apertureInfo.beam(apertureInfo.beam(i).lastOptIndex).shape(1).jacobiScale;
        %g(lastOptInd) = g(lastOptInd)+(apertureInfo.beam(i).fracFromLastOpt*apertureInfo.beam(i).doseAngleBordersDiff*apertureInfo.beam(apertureInfo.beam(i).lastOptIndex).gantryRot ...
            %./(apertureInfo.beam(apertureInfo.beam(i).lastOptIndex).doseAngleBordersDiff*apertureInfo.beam(i).gantryRot))*apertureInfo.beam(i).shape(1).shapeMap(ix)' ...
            %* bixelG(apertureInfo.beam(i).bixelIndMap(ix)) ./ apertureInfo.beam(apertureInfo.beam(i).lastOptIndex).shape(1).jacobiScale;
        
        %now leaf pos
        indInOptVec = apertureInfo.beam(apertureInfo.beam(i).lastOptIndex).shape(1).vectorOffset-1+[(1:apertureInfo.beam(apertureInfo.beam(i).lastOptIndex).numOfActiveLeafPairs) apertureInfo.totalNumOfLeafPairs+(1:apertureInfo.beam(apertureInfo.beam(i).lastOptIndex).numOfActiveLeafPairs)];
        indInBixVec = apertureInfo.beam(i).bixOffset-1+[(1:apertureInfo.beam(i).numOfActiveLeafPairs) apertureInfo.doseTotalNumOfLeafPairs+(1:apertureInfo.beam(i).numOfActiveLeafPairs)];
        
        g(indInOptVec) = g(indInOptVec)+apertureInfo.beam(i).fracFromLastOpt*apertureInfo.beam(i).shape(1).weight*bixelG(apertureInfo.bixelIndices(indInBixVec)) / apertureInfo.bixelWidth;
        
        %now time
        lastOptIndTime = lastOptInd+apertureInfo.totalNumOfShapes+apertureInfo.totalNumOfLeafPairs*2;
        g(lastOptIndTime) = g(lastOptIndTime)+(apertureInfo.beam(i).doseAngleBordersDiff.*apertureInfo.beam(apertureInfo.beam(i).lastOptIndex).timeFacCurr) ...
            .*(-apertureInfo.beam(i).fracFromLastOpt.*apertureInfo.beam(i).timeFracFromNextOpt.*(apertureInfo.beam(apertureInfo.beam(i).lastOptIndex).shape(1).weight./apertureInfo.beam(apertureInfo.beam(i).nextOptIndex).doseAngleBordersDiff).*(apertureInfo.beam(apertureInfo.beam(i).nextOptIndex).time./apertureInfo.beam(apertureInfo.beam(i).lastOptIndex).time.^2) ...
            +(1-apertureInfo.beam(i).fracFromLastOpt).*apertureInfo.beam(i).timeFracFromLastOpt.*(apertureInfo.beam(apertureInfo.beam(i).nextOptIndex).shape(1).weight./apertureInfo.beam(apertureInfo.beam(i).lastOptIndex).doseAngleBordersDiff).*(1./apertureInfo.beam(apertureInfo.beam(i).nextOptIndex).time)) ... 
            * apertureInfo.beam(i).shape(1).shapeMap(ix)' * bixelG(apertureInfo.beam(i).bixelIndMap(ix));
        
        %give the other fraction to next optimized beam
        
        %first weight
        nextOptInd = find(optBeams == apertureInfo.beam(i).nextOptIndex,1);
        g(nextOptInd) = g(nextOptInd)+(1-apertureInfo.beam(i).fracFromLastOpt).*(apertureInfo.beam(i).time./apertureInfo.beam(apertureInfo.beam(i).nextOptIndex).time) ...
            *apertureInfo.beam(i).shape(1).shapeMap(ix)' * bixelG(apertureInfo.beam(i).bixelIndMap(ix))./apertureInfo.beam(apertureInfo.beam(i).nextOptIndex).shape(1).jacobiScale;
        %g(nextOptInd) = g(nextOptInd)+((1-apertureInfo.beam(i).fracFromLastOpt)*apertureInfo.beam(i).doseAngleBordersDiff*apertureInfo.beam(apertureInfo.beam(i).nextOptIndex).gantryRot ...
            %./(apertureInfo.beam(apertureInfo.beam(i).nextOptIndex).doseAngleBordersDiff*apertureInfo.beam(i).gantryRot))*apertureInfo.beam(i).shape(1).shapeMap(ix)' ...
            %* bixelG(apertureInfo.beam(i).bixelIndMap(ix)) ./ apertureInfo.beam(apertureInfo.beam(i).nextOptIndex).shape(1).jacobiScale;
        
        %now leaf pos
        indInOptVec = apertureInfo.beam(apertureInfo.beam(i).nextOptIndex).shape(1).vectorOffset-1+[(1:apertureInfo.beam(apertureInfo.beam(i).nextOptIndex).numOfActiveLeafPairs) apertureInfo.totalNumOfLeafPairs+(1:apertureInfo.beam(apertureInfo.beam(i).nextOptIndex).numOfActiveLeafPairs)];
        indInBixVec = apertureInfo.beam(i).bixOffset-1+[(1:apertureInfo.beam(i).numOfActiveLeafPairs) apertureInfo.doseTotalNumOfLeafPairs+(1:apertureInfo.beam(i).numOfActiveLeafPairs)];
        
        g(indInOptVec) = g(indInOptVec)+(1-apertureInfo.beam(i).fracFromLastOpt)*apertureInfo.beam(i).shape(1).weight*bixelG(apertureInfo.bixelIndices(indInBixVec)) / apertureInfo.bixelWidth;
        
        %now time
        nextOptIndTime = nextOptInd+apertureInfo.totalNumOfShapes+apertureInfo.totalNumOfLeafPairs*2;
        g(nextOptIndTime) = g(nextOptIndTime)+(apertureInfo.beam(i).doseAngleBordersDiff.*apertureInfo.beam(apertureInfo.beam(i).nextOptIndex).timeFacCurr) ...
            .*(apertureInfo.beam(i).fracFromLastOpt.*apertureInfo.beam(i).timeFracFromNextOpt.*(apertureInfo.beam(apertureInfo.beam(i).lastOptIndex).shape(1).weight./apertureInfo.beam(apertureInfo.beam(i).nextOptIndex).doseAngleBordersDiff).*(1./apertureInfo.beam(apertureInfo.beam(i).lastOptIndex).time) ...
            -(1-apertureInfo.beam(i).fracFromLastOpt).*apertureInfo.beam(i).timeFracFromLastOpt.*(apertureInfo.beam(apertureInfo.beam(i).nextOptIndex).shape(1).weight./apertureInfo.beam(apertureInfo.beam(i).lastOptIndex).doseAngleBordersDiff).*(apertureInfo.beam(apertureInfo.beam(i).lastOptIndex).time./apertureInfo.beam(apertureInfo.beam(i).nextOptIndex).time.^2)) ...
            * apertureInfo.beam(i).shape(1).shapeMap(ix)' * bixelG(apertureInfo.beam(i).bixelIndMap(ix));
        
    end
end


% correct the sign for the left leaf positions
g(apertureInfo.totalNumOfShapes+1:apertureInfo.totalNumOfShapes+apertureInfo.totalNumOfLeafPairs) = ...
    -g(apertureInfo.totalNumOfShapes+1:apertureInfo.totalNumOfShapes+apertureInfo.totalNumOfLeafPairs);

