function g = matRad_daoGradFunc(apertureInfoVec,apertureInfo,dij,cst,options,daoVec2ApertureInfo)
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% matRad IPOPT callback: gradient function for direct aperture optimization
%
% call
%   g = matRad_daoGradFunc(apertureInfoVec,apertureInfo,dij,cst,type)   
%
% input
%   apertureInfoVect: aperture info in form of vector
%   apertureInfo:     aperture info struct
%   dij:              matRad dij struct as generated by bixel-based dose calculation
%   cst:              matRad cst struct
%   options:          option struct defining the type of optimization
%
% output
%   g: gradient
%
% References
%   [1] http://dx.doi.org/10.1118/1.4914863
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Copyright 2015 the matRad development team. 
% 
% This file is part of the matRad project. It is subject to the license 
% terms in the LICENSE file found in the top-level directory of this 
% distribution and at https://github.com/e0404/matRad/LICENSES.txt. No part 
% of the matRad project, including this file, may be copied, modified, 
% propagated, or distributed except according to the terms contained in the 
% LICENSE file.
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% update apertureInfo, bixel weight vector an mapping of leafes to bixels
if ~isequal(apertureInfoVec,apertureInfo.apertureVector)
    apertureInfo = daoVec2ApertureInfo(apertureInfo,apertureInfoVec);
end

% bixel based gradient calculation
bixelG = matRad_gradFuncWrapper(apertureInfo.bixelWeights,dij,cst,options);
    
% allocate gradient vector for aperture weights and leaf positions
%changed from NaNs to zeros
g = zeros(size(apertureInfoVec,1),1);

if options.VMAT
    %we're doing VMAT
    offset = 1;
    
    % 1. calculate aperatureGrad
    % 2. find corresponding bixel to the leaf Positions and aperture
    % weights to calculate the gradient
    
    % loop over all beams
    
    optBeams = find([apertureInfo.beam(:).optimizeBeam]);
    
    for i = 1:numel(apertureInfo.beam)
                
        % get used bixels in beam
        ix = ~isnan(apertureInfo.beam(i).bixelIndMap);
        
        if apertureInfo.beam(i).optimizeBeam
            %optimized beam, do regular gradient
            %must always add to existing gradient, since gradient comes
            %from optimized and interpolated beams
            g(offset) = g(offset)+apertureInfo.beam(i).shape(1).shapeMap(ix)' ...
                * bixelG(apertureInfo.beam(i).bixelIndMap(ix));
            
            
            %gradient wrt leaf positions
            indInOptVec = apertureInfo.beam(i).shape(1).vectorOffset-1+[(1:apertureInfo.beam(i).numOfActiveLeafPairs) apertureInfo.totalNumOfLeafPairs+(1:apertureInfo.beam(i).numOfActiveLeafPairs)];
            indInBixVec = apertureInfo.beam(i).bixOffset-1+[(1:apertureInfo.beam(i).numOfActiveLeafPairs) apertureInfo.doseTotalNumOfLeafPairs+(1:apertureInfo.beam(i).numOfActiveLeafPairs)];
            
            g(indInOptVec) = g(indInOptVec)+apertureInfoVec(i)*bixelG(apertureInfo.bixelIndices(indInBixVec)) / apertureInfo.bixelWidth;
            
            %increment offset
            offset = offset+1;
        else
            %not optimized beam, aperture weight is interpolated between
            %previous and next optimized weights
            
            %give fraction of gradient to previous optimized beam
            
            %first weight
            lastOptInd = (optBeams == apertureInfo.beam(i).lastOptIndex);
            g(lastOptInd) = g(lastOptInd)+apertureInfo.beam(i).fracFromLastOpt*apertureInfo.beam(i).shape(1).shapeMap(ix)' ...
                * bixelG(apertureInfo.beam(i).bixelIndMap(ix));
            
            %now leaf pos
            indInOptVec = apertureInfo.beam(apertureInfo.beam(i).lastOptIndex).shape(1).vectorOffset-1+[(1:apertureInfo.beam(apertureInfo.beam(i).lastOptIndex).numOfActiveLeafPairs) apertureInfo.totalNumOfLeafPairs+(1:apertureInfo.beam(apertureInfo.beam(i).lastOptIndex).numOfActiveLeafPairs)];
            indInBixVec = apertureInfo.beam(i).bixOffset-1+[(1:apertureInfo.beam(i).numOfActiveLeafPairs) apertureInfo.doseTotalNumOfLeafPairs+(1:apertureInfo.beam(i).numOfActiveLeafPairs)];
            
            %This is an approximation, we are assuming that the gantry
            %spends equal time in the arcs before and after the current arc
            %actual MU is MU = f1*t1/t*MU1+f2*t2/t*MU2, where t is the time
            %in the current arc
            g(indInOptVec) = g(indInOptVec)+(apertureInfo.beam(i).doseAngleBordersDiff/apertureInfo.beam(apertureInfo.beam(i).lastOptIndex).doseAngleBordersDiff)*apertureInfo.beam(i).fracFromLastOpt*apertureInfo.beam(i).shape(1).weight*bixelG(apertureInfo.bixelIndices(indInBixVec)) / apertureInfo.bixelWidth;
            
            
            
            %give the other fraction to next optimized beam
            
            %first weight
            nextOptInd = (optBeams == apertureInfo.beam(i).nextOptIndex);
            g(nextOptInd) = g(nextOptInd)+(1-apertureInfo.beam(i).fracFromLastOpt)*apertureInfo.beam(i).shape(1).shapeMap(ix)' ...
                * bixelG(apertureInfo.beam(i).bixelIndMap(ix));
            
            %now leaf pos
            indInOptVec = apertureInfo.beam(apertureInfo.beam(i).nextOptIndex).shape(1).vectorOffset-1+[(1:apertureInfo.beam(apertureInfo.beam(i).nextOptIndex).numOfActiveLeafPairs) apertureInfo.totalNumOfLeafPairs+(1:apertureInfo.beam(apertureInfo.beam(i).nextOptIndex).numOfActiveLeafPairs)];
            indInBixVec = apertureInfo.beam(i).bixOffset-1+[(1:apertureInfo.beam(i).numOfActiveLeafPairs) apertureInfo.doseTotalNumOfLeafPairs+(1:apertureInfo.beam(i).numOfActiveLeafPairs)];
            
            g(indInOptVec) = g(indInOptVec)+(apertureInfo.beam(i).doseAngleBordersDiff/apertureInfo.beam(apertureInfo.beam(i).nextOptIndex).doseAngleBordersDiff)*(1-apertureInfo.beam(i).fracFromLastOpt)*apertureInfo.beam(i).shape(1).weight*bixelG(apertureInfo.bixelIndices(indInBixVec)) / apertureInfo.bixelWidth;
        end
        
        
    end
    
    % 3. set to 0 gradient wrt the times, for now.  Later on we may want to add
    % in a dependence of obj function on total time
    g((apertureInfo.totalNumOfShapes+2*apertureInfo.totalNumOfLeafPairs+1):(2*apertureInfo.totalNumOfShapes+2*apertureInfo.totalNumOfLeafPairs-1)) = 0;
    
else
    %we're not doing VMAT
    
    % 1. calculate aperatureGrad
    % loop over all beams
    offset = 0;
    for i = 1:numel(apertureInfo.beam)
        
        % get used bixels in beam
        ix = ~isnan(apertureInfo.beam(i).bixelIndMap);
        
        % loop over all shapes and add up the gradients x openingFrac for this shape
        for j = 1:apertureInfo.beam(i).numOfShapes
            g(j+offset) = apertureInfo.beam(i).shape(j).shapeMap(ix)' ...
                * bixelG(apertureInfo.beam(i).bixelIndMap(ix));
        end
        
        % increment offset
        offset = offset + apertureInfo.beam(i).numOfShapes;
        
    end
    
    % 2. find corresponding bixel to the leaf Positions and aperture
    % weights to calculate the gradient
    g(apertureInfo.totalNumOfShapes+1:apertureInfo.totalNumOfShapes+apertureInfo.totalNumOfLeafPairs*2) = ...
        apertureInfoVec(apertureInfo.mappingMx(apertureInfo.totalNumOfShapes+1:apertureInfo.totalNumOfShapes+apertureInfo.totalNumOfLeafPairs*2,2)) ...
        .* bixelG(apertureInfo.bixelIndices(1:apertureInfo.totalNumOfLeafPairs*2)) / apertureInfo.bixelWidth;
    
end




% correct the sign for the left leaf positions
g(apertureInfo.totalNumOfShapes+1:apertureInfo.totalNumOfShapes+apertureInfo.totalNumOfLeafPairs) = ...
    -g(apertureInfo.totalNumOfShapes+1:apertureInfo.totalNumOfShapes+apertureInfo.totalNumOfLeafPairs);

